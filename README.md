# CSCI 362 Blog

## HW0: Introduction

My name is Ethan Graham.
I am now a senior at Cofc. If campus opens and we can move into dorms I will be living in a historic house on Meeting St. 

## HW1: Chapter 1

**1.3 What are the four important attributes that all professional software should possess? Suggest four other attributes that may sometimes be significant.**
  - Acceptability 
  - Dependability & Security
  - Efficiency
  - Maintainability
  
**1.8 Discuss whether professional software engineers should be liscensed in the same way as doctors or lawyers.**
  - I believe that professional software engineers should be liscenesed the same way doctors are liscenced. I believe this because Software engineers are responsible for the software in devices that can impact a person health such as insulin pumps to ai. They should be liscened so only people who aren't ignorant to ethics can   
    create the software with minimal accidents that could happen. 
    
**1.9 For each of the clauses in the ACM/IEEE Code of Ethics shown in Figure 1.4, propose an appropriate example that illustrates that clause.**
  -Public: Software engineers shouldn't create software that could negatively impact the general public or clients such as viruses. 
  
  -Client and Employer: Duty to fulfil your job of creating software that only has one purpose without being used for secondary purposes that goes against public
   interest such as obtaining and then selling personal information.
   
  -Product: Software engineers should test the integrity and functionality of ther programs before submitting there final product.
  
  -Judgement: Software engineer should be able to refuse to work on something that is against their ethics.
  
  -Management: Software engineering managers should be enforcing ethical software development and hold members accountable for violating ethics or legal rules.
  
  -Profession: Software engineers shouldn't be postponing maintaining the integretiyof their software for personal gain.
  
  -Colleagues: Software engineers should be respectful of other Software engineers and be able to have intellectual conversations without consequences.
  
  -Self: Software engineers should be continuously testing themselves and pushing themselves to learn more.
  
**1.10 To help counter terrorism, many countries are planning or have developed computer systems that track large numbers of their citizens and their actions. Clearly, this has privacy implications. Discuss the ethics of working on the development of this type of system.**
  - There are many ethical issues to having software that tracks large numbers of citizens and their actions because the information could be stolen or used for a secondary purpose by others such as the government will not willing close it.

## HW2: Reflections on software engineering practices

Brook’s [“No Silver Bullet”](http://bowringj.people.cofc.edu/classes/csci%20362/docs/NoSilverBulletOriginal.pdf), Neville-Neil’s [“Kode Vicious”](http://bowringj.people.cofc.edu/classes/csci%20362/docs/p32-neville-neil.pdf), and Potvin & Levenberg’s [“Why Google Stores Billions of Lines of Code in a Single Repository”](http://bowringj.people.cofc.edu/classes/csci%20362/docs/GoogleCodeRepo-78-potvin.pdf?id=0B2El51RQ1MQnTTVWYVNiOWhuX0U) have a common theme and argument that starting small and over time growing incrementally is extremely beneficial to software and its development. Brooks, Neville-Neil, and Potvin & Levenberg all also argue the importance and benefits to having a history of previous instances and versions of the software. They argue that making small commits consistently and frequently is important as by having this history of commits and versions of the software the integrity of the software is maintained. This also makes it significantly easier to go back and restore the code from a previous version or adjust a part of the code to that of a previous version. In Neville-Neil’s “Kode Vicious” he talks about how one way to approach a problem is to apply the scientific method to it and make the problem the hypothesis that is to be proven or disproven through different tests. Doing this lets him have a log of tests that he could potentially use in the future if he comes across a similar issue in the code. Having the log of proven and disproven tests makes it easier so he does not use a test that did not work in the past. Neville-Neil’s claim that all code should be stored and backed up in some form of version control way is supported by Potvin and Levenberg in “Why Google Stores Billions of Lines of Code in a Single Repository” where Potvin and Levenberg describe the many advantages to storing and vigilantly maintaining a monolithic repository, which stores the history of all the code versions as well as making it possible for a worldwide team of developers to work on a single source code. Brook also adds to this concept by also praising the idea of growing software over building software. He recommends that all developers first have a small working base, this makes it easier to add to it without problems such as over-complication happening or even missing the entire point of the software’s purpose. Both Brooks and Neville-Neil believe in the merits and benefits of science and that software engineers should be basing their inspirations on natures complexities. Brook’s also advocates for top down software design as it is a “top-down growing of the software”. This argument lines up with Google’s approach to improving and developing their codebase. Brook’s, Neville-Neil, and Potvin & Levenberg all agree that well-designed, maintainable code that is adaptable to the user or clients changing needs is grown from a single base source, edited in small batched, tested, and merged to the master source. Google’s monolithic repo that has billions of lines of code is not for everyone. It is best suited for organizations that are as large as Google where they have an open and collaborative culture. Having the code in one repo makes code sharing encouraged as well as being able to reuse the code more possible. This makes it possible for developers to share ideas and learn from each other which saves redundancies across the code.
